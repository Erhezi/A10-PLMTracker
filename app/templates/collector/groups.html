{% extends 'base.html' %}
{% set can_manage_cleanup = current_user.user_role == 'admin' %}
{% set can_edit = current_user.user_role != 'view-only' %}
{% block title %}Groups — PLM Tracker{% endblock %}
{% block content %}
<h1 class="h4 fw-semibold mb-3 d-flex align-items-center flex-wrap gap-2">
  <span>
    Item Groups
    <a
      href="{{ url_for('collector.item_group_doc') }}"
      class="text-decoration-none text-accent-pink d-inline-flex align-items-center"
      style="font-size: 0.6em; vertical-align: super; margin-left: 0.25em;"
      title="Open Item Group Guide"
    >
      <i class="bi bi-info-circle" aria-hidden="true"></i>
      <span class="visually-hidden">Open Item Group Guide</span>
    </a>
  </span>
</h1>
<p class="text-muted small">List all items entered for tracking</p>

{% if can_edit %}
<div class="d-flex flex-wrap gap-2 align-items-center mb-3" id="batch-action-toolbar">
  <div class="btn-group btn-group-sm" role="group" aria-label="Batch change actions">
    <button type="button" class="btn btn-outline-primary batch-action-btn" data-action="stage" disabled>Change Project Stage</button>
    <button type="button" class="btn btn-outline-primary batch-action-btn" data-action="wrike_id1" disabled>Create Wrike Task - Get Item #</button>
    <button type="button" class="btn btn-outline-primary batch-action-btn" data-action="wrike_id2" disabled>Create Wrike Task - Set-up Inv.</button>
    <button type="button" class="btn btn-outline-primary batch-action-btn" data-action="wrike_id3" disabled>Create Wrike Task - Set-up Par</button>
    <button type="button" class="btn btn-outline-primary batch-action-btn" data-action="wrike_id4" disabled>Create Wrike Task - Update Desc.</button>
    <button type="button" class="btn btn-outline-primary batch-action-btn" data-action="go_live" disabled>Change Go Live Date</button>
  </div>
  <div class="d-flex align-items-center gap-2 ms-auto">
    <div class="btn-group btn-group-sm" role="group" aria-label="Selection visibility" id="selection-visibility-group">
      <button type="button" class="btn btn-outline-secondary d-none" id="show-selected-btn">Show Selected</button>
      <button type="button" class="btn btn-outline-secondary d-none" id="show-all-btn">Show All</button>
    </div>
    <div class="form-check form-switch" id="batch-mode-switch">
      <input class="form-check-input" type="checkbox" role="switch" id="batch-mode-toggle">
      <label class="form-check-label" for="batch-mode-toggle">Batch Change</label>
    </div>
  </div>
</div>
{% endif %}

<div class="d-flex align-items-end gap-3 flex-wrap mb-2">
  <div style="width:170px;">
    <label for="filter-mode" class="form-label small mb-1 text-muted">Filter Mode</label>
    <select id="filter-mode" class="form-select form-select-sm">
      <option value="contains">Contains (any col)</option>
      <option value="not-contains">Not Contains (any col)</option>
  <option value="item-group">By Item Group</option>
  <option value="stage">By Stage</option>
      <option value="item">Item</option>
      <option value="replace-item">Replace Item</option>
    </select>
  </div>
  <div class="flex-grow-1" style="max-width:720px;">
    <label for="filter-input" class="form-label small mb-1 text-muted">Quick Filter</label>
    <div class="d-flex align-items-end gap-2 flex-nowrap">
      <div class="flex-grow-1">
        <div class="input-group input-group-sm">
          <input id="filter-input" type="text" class="form-control" placeholder="Type to filter..." autocomplete="off" />
          <button type="button" class="btn btn-outline-secondary" id="filter-clear-btn">Clear All</button>
        </div>
      </div>
      <span id="filter-hint" class="small text-muted flex-shrink-0">Use ";" to search multiple terms (max 10).</span>
    </div>
  </div>
  <div class="ms-auto d-flex align-items-end gap-2 flex-wrap justify-content-end text-end">
    <div class="small text-muted flex-shrink-0">Rows: <span id="visible-count">0</span> / {{ items|length }}</div>
    <div class="small text-muted flex-shrink-0 d-none" id="selected-count-container">Selected: <span id="selected-count">0</span></div>
    {% set clear_disabled_reason = None %}
    {% if not can_manage_cleanup %}
      {% set clear_disabled_reason = 'Only admins can clear deleted rows.' %}
    {% elif count_deleted == 0 %}
      {% set clear_disabled_reason = 'No rows with stage Deleted to clear.' %}
    {% endif %}
    <form id="clear-deleted-form" method="post" action="{{ url_for('collector.clear_deleted') }}" onsubmit="return confirm('Delete all rows with stage=Deleted? This cannot be undone.');" class="m-0">
      <button
        id="clear-deleted-btn"
        type="submit"
        class="btn btn-sm btn-outline-danger"
        data-can-manage="{{ 1 if can_manage_cleanup else 0 }}"
        data-empty-title="No rows with stage Deleted to clear."
        data-locked-title="Only admins can clear deleted rows."
        {% if clear_disabled_reason %}disabled title="{{ clear_disabled_reason }}"{% endif %}
      >
        Clear Deleted (<span id="clear-deleted-count">{{ count_deleted }}</span>)
      </button>
    </form>
    {% set archive_disabled_reason = None %}
    {% if not can_manage_cleanup %}
      {% set archive_disabled_reason = 'Only admins can archive completed rows.' %}
    {% elif count_completed == 0 %}
      {% set archive_disabled_reason = 'No rows with stage Tracking Completed to archive.' %}
    {% endif %}
    <form id="archive-completed-form" method="post" action="{{ url_for('collector.archive_completed') }}" onsubmit="return confirm('Archive all rows with stage=Tracking Completed? This removes them from the tracker.');" class="m-0">
      <button
        id="archive-completed-btn"
        type="submit"
        class="btn btn-sm btn-outline-secondary"
        data-can-manage="{{ 1 if can_manage_cleanup else 0 }}"
        data-empty-title="No rows with stage Tracking Completed to archive."
        data-locked-title="Only admins can archive completed rows."
        {% if archive_disabled_reason %}disabled title="{{ archive_disabled_reason }}"{% endif %}
      >
        Archive Completed (<span id="archive-completed-count">{{ count_completed }}</span>)
      </button>
    </form>
  </div>
</div>

<div class="table-responsive position-relative border rounded shadow-sm" style="max-height:640px; overflow:auto;">
  <table class="table table-sm table-hover align-middle mb-0" id="itemlink-table">
    <thead class="table-light small sticky-top shadow-sm" style="z-index:5;">
      <tr>
  <th style="width:46px;" class="text-center sortable select-header d-none" data-type="none"><input type="checkbox" id="batch-select-all" class="form-check-input" title="Select all"></th>
  {% if can_edit %}
  <th style="width:58px;" class="text-center sortable edit-header" data-sort="none" data-type="none">Edit <span class="sort-indicator"></span></th>
  {% endif %}
        <th class="text-center sortable" data-type="number" style="min-width:50px; width:50px;">Item Group <span class="sort-indicator"></span></th>
        <th class="sortable col-src" data-type="text" style="min-width:70px;">Item <span class="sort-indicator"></span></th>
        <th class="sortable col-src" data-type="text">Mfg Part # <span class="sort-indicator"></span></th>
        <th class="sortable col-src" data-type="text">Mfg <span class="sort-indicator"></span></th>
        <th class="sortable col-src col-desc" data-type="text" style="min-width:240px;">Item Description <span class="sort-indicator"></span></th>
        <th class="sortable col-repl" data-type="text" style="width:70px; min-width:70px; max-width:70px;">Replace Item <span class="sort-indicator"></span></th>
        <th class="sortable col-repl" data-type="text">Repl Mfg # <span class="sort-indicator"></span></th>
        <th class="sortable col-repl" data-type="text">Repl Mfg <span class="sort-indicator"></span></th>
        <th class="sortable col-repl" data-type="text" style="min-width:240px;">Repl Description <span class="sort-indicator"></span></th>
        <th class="text-center sortable" data-type="stage">Stage <span class="sort-indicator"></span></th>
        <th class="sortable text-center wrike-col" data-type="wrike"><small class="wrike-id text-muted">Wrike ID1</small> Get Item # <span class="sort-indicator"></span></th>
        <th class="sortable text-center wrike-col" data-type="wrike"><small class="wrike-id text-muted">Wrike ID2</small> Set-up Inv. <span class="sort-indicator"></span></th>
        <th class="sortable text-center wrike-col" data-type="wrike"><small class="wrike-id text-muted">Wrike ID3</small> Set-up Par <span class="sort-indicator"></span></th>
        <th class="sortable text-center wrike-col" data-type="wrike"><small class="wrike-id text-muted">Wrike ID4</small> Update Desc <span class="sort-indicator"></span></th>
        <th class="sortable text-center go-live-col" data-type="date" style="min-width:90px; width:90px;">Go Live <span class="sort-indicator"></span></th>
        <th class="sortable text-center" data-type="date">CreateDT <span class="sort-indicator"></span></th>
        <th class="sortable text-center" data-type="datetime">UpdateDT <span class="sort-indicator"></span></th>
      </tr>
    </thead>
    <tbody class="small">
      {% if items %}
        {% for r in items %}
          <tr data-item="{{ r.item }}" data-replace-item="{{ r.replace_item }}" data-item-group="{{ r.item_group }}" data-pkid="{{ r.pkid }}">
          <td class="text-center select-cell d-none">
            <input type="checkbox" class="form-check-input row-select" />
          </td>
          {% if can_edit %}
          <td class="text-center edit-cell">
            <button class="btn btn-outline-primary btn-sm edit-btn" type="button">Edit</button>
            <div class="d-none action-buttons">
              <button class="btn btn-success btn-sm save-btn" type="button" title="Save changes">Save</button>
              <button class="btn btn-secondary btn-sm cancel-btn" type="button" title="Cancel edits">Cancel</button>
            </div>
          </td>
          {% endif %}
          <td class="text-center fw-semibold" data-column="item-group" style="min-width:50px;">{{ r.item_group }}</td>
          <td class="font-monospace col-src">{{ r.item }}</td>
          <td title="{{ r.mfg_part_num }}" class="text-truncate col-src" style="max-width:140px;">{{ r.mfg_part_num }}</td>
          <td class="text-truncate col-src" style="max-width:120px;">{{ r.manufacturer }}</td>
          <td class="text-truncate col-src col-desc" style="max-width:260px;" title="{{ r.item_description }}">{{ r.item_description }}</td>
          {% set repl_active = replace_item_active_map.get(r.replace_item) if replace_item_active_map is defined else None %}
          {% set repl_inactive = repl_active and repl_active|string|lower == 'no' %}
          <td class="font-monospace ellipsis col-70 col-repl" title="{% if r.replace_item is not none %}{{ r.replace_item }}{% endif %}">
            {% if r.stage == 'Tracking - Discontinued' and (r.replace_item is none or r.replace_item|string|lower in ['nan','']) %}
              <span class="text-muted fst-italic">null</span>
            {% else %}<span class="ellipsis-text{% if repl_inactive %} text-danger fw-semibold{% endif %}">{{ r.replace_item }}</span>{% endif %}
          </td>
          <td title="{{ r.repl_mfg_part_num }}" class="text-truncate col-repl" style="max-width:140px;">
            {% if r.stage == 'Tracking - Discontinued' and (r.repl_mfg_part_num is none or r.repl_mfg_part_num|string|lower in ['nan','']) %}
              <span class="text-muted fst-italic">null</span>
            {% else %}{{ r.repl_mfg_part_num }}{% endif %}
          </td>
          <td class="text-truncate col-repl" style="max-width:120px;">
            {% if r.stage == 'Tracking - Discontinued' and (r.repl_manufacturer is none or r.repl_manufacturer|string|lower in ['nan','']) %}
              <span class="text-muted fst-italic">null</span>
            {% else %}{{ r.repl_manufacturer }}{% endif %}
          </td>
          <td class="text-truncate col-repl" style="max-width:260px;" title="{{ r.repl_item_description }}">
            {% if r.stage == 'Tracking - Discontinued' and (r.repl_item_description is none or r.repl_item_description|string|lower in ['nan','']) %}
              <span class="text-muted fst-italic">null</span>
            {% else %}{{ r.repl_item_description }}{% endif %}
          </td>
          {% set wrike = r.wrike %}
          {% set wrike_id1 = wrike.wrike_id1 if wrike else '' %}
          {% set wrike_id2 = wrike.wrike_id2 if wrike else '' %}
          {% set wrike_id3 = wrike.wrike_id3 if wrike else '' %}
          {% set wrike_id4 = wrike.wrike_id4 if wrike else '' %}
          <td class="stage-cell text-center" data-value="{{ r.stage or '' }}">
            <span class="read-value">
              {% if r.stage %}
                <span class="badge stage-badge stage-{{ r.stage|lower|replace(' ', '-') }}">{{ r.stage }}</span>
              {% endif %}
            </span>
            <select class="form-select form-select-sm d-none" name="stage">
              {% for s in allowed_stages %}
                <option value="{{ s }}" {% if r.stage==s %}selected{% endif %}>{{ s }}</option>
              {% endfor %}
            </select>
          </td>
          <td class="wrike-cell text-center" data-field="wrike_id1" data-value="{{ wrike_id1 or '' }}">
            <span class="read-value">
              {% if wrike_id1 %}
                <a href="https://www.wrike.com/open.htm?id={{ wrike_id1 }}" target="_blank" rel="noopener" class="small">{{ wrike_id1 }}</a>
              {% else %}
                <span class="text-muted small">—</span>
              {% endif %}
            </span>
            <input type="text" pattern="\d{10}" inputmode="numeric" maxlength="10" minlength="10" class="form-control form-control-sm d-none" name="wrike_id1" value="{{ wrike_id1 or '' }}" />
          </td>
          <td class="wrike-cell text-center" data-field="wrike_id2" data-value="{{ wrike_id2 or '' }}">
            <span class="read-value">
              {% if wrike_id2 %}
                <a href="https://www.wrike.com/open.htm?id={{ wrike_id2 }}" target="_blank" rel="noopener" class="small">{{ wrike_id2 }}</a>
              {% else %}
                <span class="text-muted small">—</span>
              {% endif %}
            </span>
            <input type="text" pattern="\d{10}" inputmode="numeric" maxlength="10" minlength="10" class="form-control form-control-sm d-none" name="wrike_id2" value="{{ wrike_id2 or '' }}" />
          </td>
          <td class="wrike-cell text-center" data-field="wrike_id3" data-value="{{ wrike_id3 or '' }}">
            <span class="read-value">
              {% if wrike_id3 %}
                <a href="https://www.wrike.com/open.htm?id={{ wrike_id3 }}" target="_blank" rel="noopener" class="small">{{ wrike_id3 }}</a>
              {% else %}
                <span class="text-muted small">—</span>
              {% endif %}
            </span>
            <input type="text" pattern="\d{10}" inputmode="numeric" maxlength="10" minlength="10" class="form-control form-control-sm d-none" name="wrike_id3" value="{{ wrike_id3 or '' }}" />
          </td>
          <td class="wrike-cell text-center" data-field="wrike_id4" data-value="{{ wrike_id4 or '' }}">
            <span class="read-value">
              {% if wrike_id4 %}
                <a href="https://www.wrike.com/open.htm?id={{ wrike_id4 }}" target="_blank" rel="noopener" class="small">{{ wrike_id4 }}</a>
              {% else %}
                <span class="text-muted small">—</span>
              {% endif %}
            </span>
            <input type="text" pattern="\d{10}" inputmode="numeric" maxlength="10" minlength="10" class="form-control form-control-sm d-none" name="wrike_id4" value="{{ wrike_id4 or '' }}" />
          </td>
          <td class="date-cell text-center" data-value="{{ r.expected_go_live_date }}" style="width:90px; min-width:90px;">
            <span class="read-value">
              {% if not r.expected_go_live_date or r.expected_go_live_date|string|lower in ['nan','none',''] %}
                <span class="text-muted fst-italic">unknown</span>
              {% else %}
                {{ r.expected_go_live_date }}
              {% endif %}
            </span>
            <input type="date" class="form-control form-control-sm d-none" name="expected_go_live_date" value="{{ r.expected_go_live_date }}" />
          </td>
          <td class="text-nowrap text-muted" style="font-size: .7rem;">{{ r.create_dt.strftime('%Y-%m-%d') if r.create_dt else '' }}</td>
          <td class="text-nowrap text-muted" style="font-size: .7rem;">{{ r.update_dt.strftime('%Y-%m-%d %H:%M:%S') if r.update_dt else '' }}</td>
        </tr>
        {% endfor %}
      {% else %}
      <tr><td colspan="18" class="text-muted fst-italic">No ItemLink records.</td></tr>
      {% endif %}
    </tbody>
  </table>
</div>

<div class="mt-4" id="groups-stage-stats">
  {% include 'collector/_collect_stages_stats.html' %}
</div>

<script type="application/json" id="stage-stats-data">
  {{ {
    "counts": stage_counts,
    "unstaged": stage_counts_unstaged,
    "extra": stage_counts_extra,
    "active_total": stage_active_total
  } | tojson }}
</script>

<!-- Batch action modals -->
<div class="modal fade" id="batch-stage-modal" tabindex="-1" aria-labelledby="batch-stage-label" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="batch-stage-label">Change Project Stage</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="small text-muted mb-2">Select a stage to apply to all selected rows. Prohibited transitions will be skipped automatically.</p>
        <div class="mb-3">
          <label for="batch-stage-select" class="form-label">Stage</label>
          <select class="form-select" id="batch-stage-select">
            <option value="">-- Select Stage --</option>
            {% for s in allowed_stages %}
              <option value="{{ s }}">{{ s }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="alert alert-danger d-none" id="batch-stage-error"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="batch-stage-confirm">Apply Stage</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="batch-wrike-modal" tabindex="-1" aria-labelledby="batch-wrike-label" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="batch-wrike-label">Update Wrike Task</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="small text-muted mb-2">Provide a 10-digit Wrike ID (leave blank to clear) for all selected rows.</p>
        <div class="mb-3">
          <label for="batch-wrike-input" class="form-label" id="batch-wrike-input-label">Wrike ID</label>
          <input type="text" class="form-control" id="batch-wrike-input" maxlength="10" inputmode="numeric" pattern="\d{10}">
        </div>
        <div class="alert alert-danger d-none" id="batch-wrike-error"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-success me-auto" id="batch-wrike-download-excel">Download Excel</button>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="batch-wrike-confirm">Apply Wrike ID</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="batch-go-live-modal" tabindex="-1" aria-labelledby="batch-go-live-label" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="batch-go-live-label">Change Go Live Date</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="small text-muted mb-2">Select the expected go-live date to apply to all selected rows. Leave blank to clear the date.</p>
        <div class="mb-3">
          <label for="batch-go-live-input" class="form-label">Expected Go Live Date</label>
          <input type="date" class="form-control" id="batch-go-live-input">
        </div>
        <div class="alert alert-danger d-none" id="batch-go-live-error"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="batch-go-live-confirm">Apply Date</button>
      </div>
    </div>
  </div>
</div>

<script type="application/json" id="stage-transition-map">
  {{ {"map": stage_transitions, "stages": allowed_stages}|tojson }}
</script>
<script type="application/json" id="batch-endpoints-json">
  {{ {
    "stage": url_for("collector.batch_update_stage"),
    "wrike": {
      "wrike_id1": url_for("collector.batch_update_wrike", field="wrike_id1"),
      "wrike_id2": url_for("collector.batch_update_wrike", field="wrike_id2"),
      "wrike_id3": url_for("collector.batch_update_wrike", field="wrike_id3"),
      "wrike_id4": url_for("collector.batch_update_wrike", field="wrike_id4"),
    },
    "goLive": url_for("collector.batch_update_go_live"),
  } | tojson }}
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const batchEndpoints = (() => {
    const el = document.getElementById('batch-endpoints-json');
    if(!el){
      console.error('Batch endpoint manifest missing.');
      return {};
    }
    try {
      return JSON.parse(el.textContent);
    } catch (err) {
      console.error('Unable to parse batch endpoint manifest', err);
      return {};
    }
  })();
  // All stages are already canonical; no legacy normalization needed.

  const table = document.getElementById('itemlink-table');
  const filterInput = document.getElementById('filter-input');
  const filterClearBtn = document.getElementById('filter-clear-btn');
  const filterMode = document.getElementById('filter-mode');
  const filterHint = document.getElementById('filter-hint');
  const MAX_TERMS_DEFAULT = 10;
  const MAX_TERMS_COLUMN = 100;
  const COLUMN_TOKEN_MODES = new Set(['item','replace-item']);
  const TRACKING_COMPLETED_STAGE = 'Tracking Completed';
  const TRACKING_COMPLETED_WARNING = 'Once set to Tracking Completed, this row cannot move to another stage. To revive it, archive the completed row and create a new entry. Continue?';
  const TRACKING_COMPLETED_EDIT_TOOLTIP = 'Tracking Completed rows cannot be edited. Archive the row and add a new one to make changes.';
  const BATCH_LOCKED_STAGES = new Set([TRACKING_COMPLETED_STAGE.toLowerCase()]);
  const BATCH_LOCKED_TOOLTIP = 'Tracking Completed rows cannot be included in batch actions.';
  const buildHintMessage = (limit) => `Use ";" to search multiple terms (max ${limit}).`;
  const buildOverflowMessage = (limit) => `Use ";" to search multiple terms (max ${limit}). Only the first ${limit} terms are applied.`;
  const setFilterHint = (limit, truncated) => {
    if(!filterHint) return;
    if(truncated){
      filterHint.classList.remove('text-muted');
      filterHint.classList.add('text-danger');
      filterHint.textContent = buildOverflowMessage(limit);
    } else {
      filterHint.classList.add('text-muted');
      filterHint.classList.remove('text-danger');
      filterHint.textContent = buildHintMessage(limit);
    }
  };
  const getTokenLimit = (mode) => COLUMN_TOKEN_MODES.has(mode) ? MAX_TERMS_COLUMN : MAX_TERMS_DEFAULT;
  const visibleCountEl = document.getElementById('visible-count');
  const selectedCountContainer = document.getElementById('selected-count-container');
  const selectedCountEl = document.getElementById('selected-count');
  const batchToggle = document.getElementById('batch-mode-toggle');
  const showSelectedBtn = document.getElementById('show-selected-btn');
  const showAllBtn = document.getElementById('show-all-btn');
  const batchButtons = Array.from(document.querySelectorAll('.batch-action-btn'));
  const stageBatchButton = batchButtons.find(btn => btn.dataset.action === 'stage');
  const wrikeGetItemButton = batchButtons.find(btn => btn.dataset.action === 'wrike_id1');
  const wrikeSetupInvButton = batchButtons.find(btn => btn.dataset.action === 'wrike_id2');
  const wrikeSetupParButton = batchButtons.find(btn => btn.dataset.action === 'wrike_id3');
  const wrikeUpdateDescButton = batchButtons.find(btn => btn.dataset.action === 'wrike_id4');
  const MULTI_STAGE_SELECTION_ALERT = 'Change Project Stage is only available when all selected rows share the same current stage. Filter on Stage and try again.';
  const STAGE_PENDING_ITEM_NUMBER = 'Pending Item Number';
  const WRIKE_ID1_STAGE_REQUIREMENT_MESSAGE = 'Create Wrike Task - Get Item # is only available when all selected rows are in Pending Item Number stage.';
  const STAGE_PENDING_CLINICAL_READINESS = 'Pending Clinical Readiness';
  const STAGE_TRACKING_ITEM_TRANSITION = 'Tracking - Item Transition';
  const STAGE_TRACKING_DISCONTINUED = 'Tracking - Discontinued';
  const WRIKE_PENDING_CLINICAL_SELECTION_HINT = 'Select Pending Clinical Readiness rows to create Wrike IDs.';
  const WRIKE_ID2_STAGE_REQUIREMENT_MESSAGE = 'Create Wrike Task - Set-up Inv. is only available when all selected rows are in Pending Clinical Readiness stage.';
  const WRIKE_ID3_STAGE_REQUIREMENT_MESSAGE = 'Create Wrike Task - Set-up Par is only available when all selected rows are in Pending Clinical Readiness stage.';
  const WRIKE_ID4_STAGE_REQUIREMENT_MESSAGE = 'Create Wrike Task - Update Desc. is only available when all selected rows are in Pending Clinical Readiness, Tracking - Item Transition, or Tracking - Discontinued stage.';
  const selectHeader = table ? table.querySelector('.select-header') : null;
  const editHeader = table ? table.querySelector('.edit-header') : null;
  const selectAll = document.getElementById('batch-select-all');
  const stageModalEl = document.getElementById('batch-stage-modal');
  const wrikeModalEl = document.getElementById('batch-wrike-modal');
  const goLiveModalEl = document.getElementById('batch-go-live-modal');
  const stageSelect = document.getElementById('batch-stage-select');
  const wrikeInput = document.getElementById('batch-wrike-input');
  const goLiveInput = document.getElementById('batch-go-live-input');
  const stageError = document.getElementById('batch-stage-error');
  const wrikeError = document.getElementById('batch-wrike-error');
  const goLiveError = document.getElementById('batch-go-live-error');
  const clearDeletedBtn = document.getElementById('clear-deleted-btn');
  const archiveCompletedBtn = document.getElementById('archive-completed-btn');
  const canManageClearDeleted = !!(clearDeletedBtn && clearDeletedBtn.dataset.canManage === '1');
  const canManageArchiveCompleted = !!(archiveCompletedBtn && archiveCompletedBtn.dataset.canManage === '1');
  const wrikeInputLabel = document.getElementById('batch-wrike-input-label');
  const wrikeModalTitle = wrikeModalEl ? wrikeModalEl.querySelector('.modal-title') : null;
  const bootstrapModalCtor = (typeof window !== 'undefined' && window.bootstrap && typeof window.bootstrap.Modal === 'function') ? window.bootstrap.Modal : null;
  const stageModal = stageModalEl && bootstrapModalCtor ? new bootstrapModalCtor(stageModalEl) : null;
  const wrikeModal = wrikeModalEl && bootstrapModalCtor ? new bootstrapModalCtor(wrikeModalEl) : null;
  const goLiveModal = goLiveModalEl && bootstrapModalCtor ? new bootstrapModalCtor(goLiveModalEl) : null;
  const stageConfirm = document.getElementById('batch-stage-confirm');
  const wrikeConfirm = document.getElementById('batch-wrike-confirm');
  const goLiveConfirm = document.getElementById('batch-go-live-confirm');
  const TEXT_NODE = typeof Node !== 'undefined' ? Node.TEXT_NODE : 3;
  const stageMeta = (() => {
    const el = document.getElementById('stage-transition-map');
    if(!el) return { map: {}, stages: [] };
    try {
      return JSON.parse(el.textContent);
    } catch (err) {
      console.error('Unable to parse stage transition map', err);
      return { map: {}, stages: [] };
    }
  })();
  const stageTransitionMap = stageMeta.map || {};
  const allStages = stageMeta.stages || [];
  const allowedTargetsForStage = (stage) => {
    const key = (stage || '').trim();
    const rawList = stageTransitionMap[key] || stageTransitionMap.__new__ || allStages;
    const list = Array.isArray(rawList) ? rawList : allStages;
    const set = new Set(list);
    if(key) set.add(key);
    return set;
  };
  const getRowStageValue = (row) => {
    if(!row) return '';
    const cell = row.querySelector('.stage-cell');
    if(!cell) return '';
    return (cell.dataset.value || '').trim();
  };
  const normalizeStageName = (stage) => (stage || '').trim().toLowerCase();
  const stageMatches = (stageValue, targetStage) => normalizeStageName(stageValue) === normalizeStageName(targetStage);

  const stageStats = (() => {
    const container = document.getElementById('groups-stage-stats');
    if(!container){
      return null;
    }
    const dataEl = document.getElementById('stage-stats-data');
    let initial = { counts:{}, extra:{}, unstaged:0 };
    if(dataEl){
      try {
        initial = JSON.parse(dataEl.textContent) || initial;
      } catch (err) {
        console.error('Unable to parse stage stats manifest', err);
      }
    }
    const stageBoxMap = new Map();
    container.querySelectorAll('.stage-summary-box[data-stage]').forEach(box => {
      const stageName = (box.dataset.stage || '').trim();
      if(!stageName) return;
      const countEl = box.querySelector('.stage-summary-count');
      const count = parseInt(countEl ? countEl.textContent : '0', 10);
      stageBoxMap.set(stageName, {
        box,
        countEl,
        count: Number.isNaN(count) ? 0 : count,
      });
    });
    const unstagedWrapper = container.querySelector('[data-role="stage-summary-unstaged"]');
    const unstagedValueEl = unstagedWrapper ? unstagedWrapper.querySelector('.stage-summary-value') : null;
    const extraWrapper = container.querySelector('[data-role="stage-summary-extra"]');
    const extraValuesContainer = extraWrapper ? extraWrapper.querySelector('.stage-summary-extra-values') : null;

    const extraMap = new Map();
    if(extraValuesContainer){
      extraValuesContainer.querySelectorAll('.stage-summary-extra-entry').forEach(entry => {
        const name = (entry.dataset.stage || '').trim();
        if(!name) return;
        const valueEl = entry.querySelector('.stage-summary-value');
        const value = parseInt(valueEl ? valueEl.textContent : '0', 10);
        extraMap.set(name, Number.isNaN(value) ? 0 : value);
      });
    }

    const state = {
      extra: extraMap,
      unstaged: (() => {
        if(unstagedValueEl){
          const value = parseInt(unstagedValueEl.textContent || '0', 10);
          if(!Number.isNaN(value)){
            return value;
          }
        }
        const fallback = parseInt(initial.unstaged, 10);
        return Number.isNaN(fallback) ? 0 : fallback;
      })(),
    };

    const setUnstaged = (value) => {
      const safe = Math.max(0, Number(value) || 0);
      state.unstaged = safe;
      if(unstagedValueEl){
        unstagedValueEl.textContent = String(safe);
      }
      if(unstagedWrapper){
        unstagedWrapper.classList.toggle('d-none', safe === 0);
      }
    };

    const renderExtra = () => {
      if(!extraWrapper || !extraValuesContainer) return;
      extraValuesContainer.innerHTML = '';
      const entries = Array.from(state.extra.entries())
        .filter(([, value]) => (Number(value) || 0) > 0)
        .sort(([a], [b]) => a.localeCompare(b));
      if(entries.length === 0){
        extraWrapper.classList.add('d-none');
        return;
      }
      extraWrapper.classList.remove('d-none');
      entries.forEach(([name, value], idx) => {
        if(idx > 0){
          extraValuesContainer.append(document.createTextNode(', '));
        }
        const entry = document.createElement('span');
        entry.className = 'stage-summary-extra-entry';
        entry.dataset.stage = name;
        entry.append(document.createTextNode(name));
        entry.append(document.createTextNode(' ('));
        const valueSpan = document.createElement('span');
        valueSpan.className = 'stage-summary-value';
        valueSpan.textContent = String(value);
        entry.append(valueSpan);
        entry.append(document.createTextNode(')'));
        extraValuesContainer.append(entry);
      });
    };

    const updateKnownStage = (stageName, value) => {
      const info = stageBoxMap.get(stageName);
      if(!info) return;
      const safe = Math.max(0, Number(value) || 0);
      info.count = safe;
      if(info.countEl){
        info.countEl.textContent = String(safe);
      }
    };

    const changeStageCount = (stageValue, delta) => {
      const key = (stageValue || '').trim();
      if(!key){
        setUnstaged(state.unstaged + delta);
        return;
      }
      if(stageBoxMap.has(key)){
        const current = stageBoxMap.get(key).count || 0;
        updateKnownStage(key, current + delta);
        return;
      }
      const current = state.extra.get(key) || 0;
      const next = Number(current) + delta;
      if(next <= 0){
        state.extra.delete(key);
      } else {
        state.extra.set(key, next);
      }
      renderExtra();
    };

    renderExtra();
    setUnstaged(state.unstaged);

    return {
      handleStageChange(oldStage, newStage){
        const prev = (oldStage || '').trim();
        const next = (newStage || '').trim();
        if(normalizeStageName(prev) === normalizeStageName(next)){
          return;
        }
        changeStageCount(prev, -1);
        changeStageCount(next, 1);
      },
      resetFromServer(manifest){
        const payload = manifest || {};
        const counts = payload.counts || {};
        Object.keys(counts).forEach(stageName => {
          updateKnownStage(stageName, counts[stageName]);
        });
        if(payload.extra){
          state.extra = new Map(Object.entries(payload.extra).map(([name, value]) => [name, Number(value) || 0]));
        } else {
          state.extra = new Map();
        }
        renderExtra();
        if(Object.prototype.hasOwnProperty.call(payload, 'unstaged')){
          setUnstaged(payload.unstaged);
        }
      },
    };
  })();

  function summarizeSelectionStages(rows){
    const stageSet = new Set();
    rows.forEach(row => stageSet.add(getRowStageValue(row)));
    const stages = Array.from(stageSet);
    const singleStage = stages.length === 1;
    return {
      singleStage,
      stage: singleStage ? stages[0] : null,
    };
  }

  function configureBatchStageSelect(currentStage){
    if(!stageSelect) return;
    const allowedTargets = allowedTargetsForStage(currentStage);
    Array.from(stageSelect.options).forEach(opt => {
      if(!opt.value){
        opt.disabled = false;
        return;
      }
      opt.disabled = !allowedTargets.has(opt.value);
    });
    stageSelect.value = '';
    if(currentStage === TRACKING_COMPLETED_STAGE){
      stageSelect.title = 'Tracking Completed is final; archive the row and add a new one to revive it.';
    } else {
      stageSelect.removeAttribute('title');
    }
  }

  function updateStageBatchButtonState(){
    if(!stageBatchButton){
      return;
    }
    if(batchToggle && !batchToggle.checked){
      stageBatchButton.disabled = true;
      stageBatchButton.title = 'Enable Batch Change to update project stages.';
      return;
    }
    const selectedRows = getSelectedRows();
    const { singleStage } = summarizeSelectionStages(selectedRows);
    const allow = selectedRows.length > 0 && singleStage;
    stageBatchButton.disabled = !allow;
    if(!allow){
      stageBatchButton.title = selectedRows.length === 0
        ? 'Select at least one row to change the project stage.'
        : MULTI_STAGE_SELECTION_ALERT;
    } else {
      stageBatchButton.removeAttribute('title');
    }
  }

  function updateWrikeGetItemButtonState(){
    if(!wrikeGetItemButton){
      return;
    }
    if(batchToggle && !batchToggle.checked){
      wrikeGetItemButton.disabled = true;
      wrikeGetItemButton.title = 'Enable Batch Change to update Wrike tasks.';
      return;
    }
    const selectedRows = getSelectedRows();
    if(!selectedRows.length){
      wrikeGetItemButton.disabled = true;
      wrikeGetItemButton.title = 'Select Pending Item Number rows to create Wrike IDs.';
      return;
    }
    const allPendingItemNumber = selectedRows.every(row => stageMatches(getRowStageValue(row), STAGE_PENDING_ITEM_NUMBER));
    wrikeGetItemButton.disabled = !allPendingItemNumber;
    if(!allPendingItemNumber){
      wrikeGetItemButton.title = WRIKE_ID1_STAGE_REQUIREMENT_MESSAGE;
    } else {
      wrikeGetItemButton.removeAttribute('title');
    }
  }

  function updateWrikeSetupButtonState(button, emptySelectionMessage, requirementMessage){
    if(!button){
      return;
    }
    if(batchToggle && !batchToggle.checked){
      button.disabled = true;
      button.title = 'Enable Batch Change to update Wrike tasks.';
      return;
    }
    const selectedRows = getSelectedRows();
    if(!selectedRows.length){
      button.disabled = true;
      button.title = emptySelectionMessage;
      return;
    }
    const allPendingClinical = selectedRows.every(row => stageMatches(getRowStageValue(row), STAGE_PENDING_CLINICAL_READINESS));
    button.disabled = !allPendingClinical;
    if(!allPendingClinical){
      button.title = requirementMessage;
    } else {
      button.removeAttribute('title');
    }
  }

  function updateWrikeUpdateDescButtonState(){
    if(!wrikeUpdateDescButton){
      return;
    }
    if(batchToggle && !batchToggle.checked){
      wrikeUpdateDescButton.disabled = true;
      wrikeUpdateDescButton.title = 'Enable Batch Change to update Wrike tasks.';
      return;
    }
    const selectedRows = getSelectedRows();
    if(!selectedRows.length){
      wrikeUpdateDescButton.disabled = true;
      wrikeUpdateDescButton.title = 'Select Pending Clinical Readiness, Tracking - Item Transition, or Tracking - Discontinued rows to create Wrike IDs.';
      return;
    }
    const allowed = selectedRows.every(row => {
      const stageValue = getRowStageValue(row);
      return stageMatches(stageValue, STAGE_PENDING_CLINICAL_READINESS)
        || stageMatches(stageValue, STAGE_TRACKING_ITEM_TRANSITION)
        || stageMatches(stageValue, STAGE_TRACKING_DISCONTINUED);
    });
    wrikeUpdateDescButton.disabled = !allowed;
    if(!allowed){
      wrikeUpdateDescButton.title = WRIKE_ID4_STAGE_REQUIREMENT_MESSAGE;
    } else {
      wrikeUpdateDescButton.removeAttribute('title');
    }
  }

  function updateWrikeSetupButtonsState(){
    updateWrikeSetupButtonState(wrikeSetupInvButton, WRIKE_PENDING_CLINICAL_SELECTION_HINT, WRIKE_ID2_STAGE_REQUIREMENT_MESSAGE);
    updateWrikeSetupButtonState(wrikeSetupParButton, WRIKE_PENDING_CLINICAL_SELECTION_HINT, WRIKE_ID3_STAGE_REQUIREMENT_MESSAGE);
    updateWrikeUpdateDescButtonState();
  }

  const isBatchModeEnabled = () => !!(batchToggle && batchToggle.checked);

  const getSelectedCheckboxes = () => {
    if(!table) return [];
    return Array.from(table.querySelectorAll('tbody .row-select')).filter(cb => cb.checked);
  };
  let showSelectedActive = false;

  const updateSelectedCount = () => {
    const count = getSelectedCheckboxes().length;
    if(selectedCountEl){
      selectedCountEl.textContent = count;
    }
    if(showSelectedBtn && !showSelectedActive){
      showSelectedBtn.disabled = count === 0;
    }
    updateStageBatchButtonState();
    updateWrikeGetItemButtonState();
    updateWrikeSetupButtonsState();
  };
  const isCheckboxVisible = (cb) => {
    if(!cb) return false;
    const row = cb.closest('tr');
    if(!row) return false;
    return !row.classList.contains('d-none');
  };
  const getAllRowCheckboxes = () => {
    if(!table) return [];
    return Array.from(table.querySelectorAll('tbody .row-select'));
  };
  const getVisibleCheckboxes = () => {
    if(!table) return [];
    return getAllRowCheckboxes().filter(cb => !cb.disabled && isCheckboxVisible(cb));
  };
  const syncSelectAll = () => {
    if(selectAll){
      const visibleCheckboxes = getVisibleCheckboxes();
      const allCheckboxes = getAllRowCheckboxes().filter(cb => !cb.disabled);
      const totalVisible = visibleCheckboxes.length;
      const totalSelectable = allCheckboxes.length;
      const visibleChecked = visibleCheckboxes.filter(cb => cb.checked).length;
      const totalChecked = allCheckboxes.filter(cb => cb.checked).length;
      const hasHiddenChecked = totalChecked > visibleChecked;

      if(totalVisible === 0){
        selectAll.checked = false;
        selectAll.indeterminate = totalChecked > 0;
      } else {
        const allVisibleChecked = totalVisible > 0 && visibleChecked === totalVisible;
        const anyVisibleChecked = visibleChecked > 0;
        selectAll.checked = allVisibleChecked && !hasHiddenChecked;
        selectAll.indeterminate = hasHiddenChecked || (anyVisibleChecked && !allVisibleChecked);
      }
      if(totalSelectable === 0){
        selectAll.checked = false;
        selectAll.indeterminate = false;
      }
    }
    updateSelectedCount();
  };
  const isStageBatchLocked = (stage) => BATCH_LOCKED_STAGES.has(normalizeStageName(stage));
  const updateRowEditState = (row, stageValue) => {
    if(!row) return;
    const editBtn = row.querySelector('.edit-cell .edit-btn');
    if(!editBtn) return;
    if(isBatchModeEnabled()){
      editBtn.disabled = true;
      editBtn.removeAttribute('title');
      return;
    }
    const locked = isStageBatchLocked(stageValue);
    if(locked){
      if(row.classList.contains('table-warning')){
        exitEdit(row);
      }
      editBtn.disabled = true;
      editBtn.title = TRACKING_COMPLETED_EDIT_TOOLTIP;
    } else {
      editBtn.disabled = false;
      editBtn.removeAttribute('title');
    }
  };

  const updateRowSelectionState = (row) => {
    if(!row) return;
    const stageValue = getRowStageValue(row);
    const locked = isStageBatchLocked(stageValue);
    const checkbox = row.querySelector('.row-select');
    if(checkbox){
      if(locked){
        if(checkbox.checked){
          checkbox.checked = false;
        }
        checkbox.disabled = true;
        checkbox.title = BATCH_LOCKED_TOOLTIP;
      } else {
        checkbox.disabled = false;
        checkbox.removeAttribute('title');
      }
      checkbox.classList.remove('d-none');
    }
    row.classList.toggle('batch-row-locked', locked);
    updateRowEditState(row, stageValue);
  };
  const refreshAllRowSelectionStates = () => {
    if(!table) return;
    const rows = Array.from(table.querySelectorAll('tbody tr')).filter(tr => tr.dataset.item !== undefined);
    rows.forEach(updateRowSelectionState);
    syncSelectAll();
  };
  const normalizeReplace = (value) => {
    if(value === null || value === undefined) return null;
    const trimmed = String(value).trim();
    if(!trimmed) return null;
    const lower = trimmed.toLowerCase();
    if(lower === 'none' || lower === 'null' || lower === 'nan') return null;
    return trimmed;
  };
  const buildRowKey = (item, replace) => `${item}::${(normalizeReplace(replace) || '').toLowerCase()}`;
  const createRowLookup = () => {
    const map = new Map();
    if(!table) return map;
    Array.from(table.querySelectorAll('tbody tr')).forEach(tr => {
      const item = tr.dataset.item;
      if(!item) return;
      const replace = normalizeReplace(tr.dataset.replaceItem);
      map.set(buildRowKey(item, replace), tr);
    });
    return map;
  };
  const buildPayload = (rows) => rows.map(row => {
    const payload = {
      item: row.dataset.item,
      replace_item: normalizeReplace(row.dataset.replaceItem),
    };
    if(row.dataset.pkid){
      payload.pkid = row.dataset.pkid;
    }
    return payload;
  });
  const normalizeTextValue = (value) => {
    if(value === null || value === undefined) return '';
    return String(value).trim().toLowerCase();
  };
  const getItemGroupValue = (row) => {
    const dataValue = normalizeTextValue(row.dataset.itemGroup);
    if(dataValue) return dataValue;
    const cell = row.querySelector('td[data-column="item-group"]');
    return normalizeTextValue(cell ? cell.innerText : '');
  };
  const getCellText = (row, selector) => {
    const cell = row.querySelector(selector);
    return normalizeTextValue(cell ? cell.innerText : '');
  };
  const getRowValueForMode = (row, mode) => {
    if(mode === 'item'){
      const dataVal = normalizeTextValue(row.dataset.item);
      return dataVal || getCellText(row, 'td.col-src');
    }
    if(mode === 'replace-item'){
      const dataVal = normalizeTextValue(row.dataset.replaceItem);
      return dataVal || getCellText(row, 'td.col-repl');
    }
    return '';
  };
  const updateDeletedCountUI = ({ providedCount, oldStage, newStage } = {}) => {
    const countEl = document.getElementById('clear-deleted-count');
    const btn = clearDeletedBtn;
    if(!countEl || !btn) return;
    if(providedCount !== undefined && providedCount !== null){
      const num = Number(providedCount);
      if(!Number.isNaN(num)){
        const safe = Math.max(0, num);
        countEl.textContent = safe;
        const shouldDisable = !canManageClearDeleted || safe === 0;
        btn.disabled = shouldDisable;
        if(!canManageClearDeleted && btn.dataset.lockedTitle){
          btn.title = btn.dataset.lockedTitle;
        } else if(shouldDisable && safe === 0 && btn.dataset.emptyTitle){
          btn.title = btn.dataset.emptyTitle;
        } else if(!shouldDisable){
          btn.removeAttribute('title');
        }
        return;
      }
    }
    if(oldStage === undefined || newStage === undefined) return;
    const oldNorm = (oldStage || '').trim().toLowerCase();
    const newNorm = (newStage || '').trim().toLowerCase();
    let current = parseInt(countEl.textContent || '0', 10);
    if(Number.isNaN(current)) current = 0;
    if(oldNorm === 'deleted' && newNorm !== 'deleted'){
      current = Math.max(0, current - 1);
    } else if(oldNorm !== 'deleted' && newNorm === 'deleted'){
      current += 1;
    }
    countEl.textContent = current;
    if(btn){
      const shouldDisable = !canManageClearDeleted || current === 0;
      btn.disabled = shouldDisable;
      if(!canManageClearDeleted && btn.dataset.lockedTitle){
        btn.title = btn.dataset.lockedTitle;
      } else if(shouldDisable && current === 0 && btn.dataset.emptyTitle){
        btn.title = btn.dataset.emptyTitle;
      } else if(!shouldDisable){
        btn.removeAttribute('title');
      }
    }
  };
  const updateCompletedCountUI = ({ providedCount, oldStage, newStage } = {}) => {
    const countEl = document.getElementById('archive-completed-count');
    const btn = archiveCompletedBtn;
    if(!countEl || !btn) return;
    if(providedCount !== undefined && providedCount !== null){
      const num = Number(providedCount);
      if(!Number.isNaN(num)){
        const safe = Math.max(0, num);
        countEl.textContent = safe;
        const shouldDisable = !canManageArchiveCompleted || safe === 0;
        btn.disabled = shouldDisable;
        if(!canManageArchiveCompleted && btn.dataset.lockedTitle){
          btn.title = btn.dataset.lockedTitle;
        } else if(shouldDisable && safe === 0 && btn.dataset.emptyTitle){
          btn.title = btn.dataset.emptyTitle;
        } else if(!shouldDisable){
          btn.removeAttribute('title');
        }
        return;
      }
    }
    if(oldStage === undefined || newStage === undefined) return;
    const oldNorm = (oldStage || '').trim().toLowerCase();
    const newNorm = (newStage || '').trim().toLowerCase();
    let current = parseInt(countEl.textContent || '0', 10);
    if(Number.isNaN(current)) current = 0;
    if(oldNorm === 'tracking completed' && newNorm !== 'tracking completed'){
      current = Math.max(0, current - 1);
    } else if(oldNorm !== 'tracking completed' && newNorm === 'tracking completed'){
      current += 1;
    }
    countEl.textContent = current;
    if(btn){
      const shouldDisable = !canManageArchiveCompleted || current === 0;
      btn.disabled = shouldDisable;
      if(!canManageArchiveCompleted && btn.dataset.lockedTitle){
        btn.title = btn.dataset.lockedTitle;
      } else if(shouldDisable && current === 0 && btn.dataset.emptyTitle){
        btn.title = btn.dataset.emptyTitle;
      } else if(!shouldDisable){
        btn.removeAttribute('title');
      }
    }
  };
  const applyRecordToRow = (row, rec) => {
    if(!row || !rec) return;
    const previousStage = getRowStageValue(row);
    if(Object.prototype.hasOwnProperty.call(rec, 'replace_item')){
      row.dataset.replaceItem = rec.replace_item ?? '';
    }
    const stageCell = row.querySelector('.stage-cell');
    if(stageCell){
      stageCell.dataset.value = rec.stage || '';
      const badgeWrap = stageCell.querySelector('.read-value');
      if(badgeWrap){
        badgeWrap.innerHTML = rec.stage ? `<span class="badge stage-badge stage-${(rec.stage||'').toLowerCase().replace(/ /g,'-')}">${rec.stage}</span>` : '';
      }
      const sel = stageCell.querySelector('select');
      if(sel) sel.value = rec.stage || '';
    }
    const dateCell = row.querySelector('.date-cell');
    if(dateCell){
      dateCell.dataset.value = rec.expected_go_live_date || '';
      const span = dateCell.querySelector('.read-value');
      if(span){
        if(!rec.expected_go_live_date){
          span.innerHTML = '<span class="text-muted fst-italic">unknown</span>';
        } else {
          span.textContent = rec.expected_go_live_date;
        }
      }
      const inp = dateCell.querySelector('input');
      if(inp) inp.value = rec.expected_go_live_date || '';
    }
    ['wrike_id1','wrike_id2','wrike_id3','wrike_id4'].forEach(field => {
      const cell = row.querySelector(`.wrike-cell[data-field="${field}"]`);
      if(!cell) return;
      const span = cell.querySelector('.read-value');
      const input = cell.querySelector('input');
      const value = rec[field] || '';
      cell.dataset.value = value || '';
      if(span){
        span.innerHTML = formatWrikeHtml(value);
      }
      if(input){
        input.value = value || '';
      }
    });
    const updateCell = row.querySelector('td:last-child');
    if(updateCell){
      if(rec.update_dt){
        try {
          updateCell.textContent = new Date(rec.update_dt).toISOString().slice(0,19).replace('T',' ');
        } catch {
          updateCell.textContent = rec.update_dt;
        }
      }
    }
    if(stageStats){
      stageStats.handleStageChange(previousStage, rec.stage || '');
    }
    updateRowSelectionState(row);
  };
  const showBatchSummary = (summary, failureMessages) => {
    if(!summary) return;
    const failures = Number(summary.failed) || 0;
    const hasFailureDetails = failureMessages && failureMessages.length;
    if(failures === 0 && !hasFailureDetails){
      return; // All rows succeeded; no alert necessary.
    }
    const lines = [`Batch update complete: ${summary.success || 0} succeeded.`];
    if(failures){
      lines.push(`${failures} failed.`);
    }
    if(hasFailureDetails){
      lines.push('');
      lines.push('Failed rows:');
      failureMessages.slice(0,5).forEach(msg => lines.push(msg));
      if(failureMessages.length > 5){
        lines.push(`(+${failureMessages.length - 5} more)`);
      }
    }
    alert(lines.join('\n'));
  };
  const applyBatchSummary = (summary) => {
    if(!summary) return;
    const results = Array.isArray(summary.results) ? summary.results : [];
    const rowMap = createRowLookup();
    const failureMessages = [];
    results.forEach(result => {
      const key = buildRowKey(result.item, result.replace_item);
      const row = rowMap.get(key);
      if(!row) return;
      if(result.success){
        if(result.record){
          applyRecordToRow(row, result.record);
        }
        row.classList.remove('batch-failure-flash');
      } else {
        row.classList.add('batch-failure-flash');
        if(result.message){
          failureMessages.push(`• ${result.item}${result.replace_item ? ` / ${result.replace_item}` : ''}: ${result.message}`);
        } else {
          failureMessages.push(`• ${result.item}${result.replace_item ? ` / ${result.replace_item}` : ''}: Update blocked`);
        }
        setTimeout(() => row.classList.remove('batch-failure-flash'), 4000);
      }
    });
    if(Object.prototype.hasOwnProperty.call(summary, 'count_deleted')){
      updateDeletedCountUI({ providedCount: summary.count_deleted });
    }
    if(Object.prototype.hasOwnProperty.call(summary, 'count_completed')){
      updateCompletedCountUI({ providedCount: summary.count_completed });
    }
    showBatchSummary(summary, failureMessages);
    activateShowSelectedView({ auto: true });
    refreshAllRowSelectionStates();
  };
  const submitBatch = async (url, payload, errorBox) => {
    if(errorBox){
      errorBox.classList.add('d-none');
      errorBox.textContent = '';
    }
    try {
  const resp = await appFetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'X-Requested-With': 'fetch'
        },
        body: JSON.stringify(payload)
      });
      let data = null;
      try {
        data = await resp.json();
      } catch {
        data = null;
      }
      if(!resp.ok || (data && data.status === 'error')){
        const message = data && data.message ? data.message : `Request failed (${resp.status})`;
        throw new Error(message);
      }
      if(!data){
        throw new Error('No response payload received');
      }
      return data;
    } catch (err) {
      console.error('Batch request failed', err);
      const message = err && err.message ? err.message : 'Batch request failed';
      if(errorBox){
        errorBox.textContent = message;
        errorBox.classList.remove('d-none');
      } else {
        alert(message);
      }
      return null;
    }
  };
  const withBusyState = async (button, task) => {
    if(button){
      if(button.dataset.busy === '1'){
        return null;
      }
      button.dataset.busy = '1';
      button.disabled = true;
    }
    try {
      return await task();
    } finally {
      if(button){
        delete button.dataset.busy;
        button.disabled = false;
      }
    }
  };
  const escapeHtml = (value) => {
    if(value === null || value === undefined){
      return '';
    }
    const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
    return String(value).replace(/[&<>"']/g, ch => map[ch] || ch);
  };
  const formatWrikeHtml = (value) => {
    if(!value){
      return '<span class="text-muted small">—</span>';
    }
    const safe = escapeHtml(value);
    if(/^\d{10}$/.test(value)){
      return `<a href="https://www.wrike.com/open.htm?id=${safe}" target="_blank" rel="noopener" class="small">${safe}</a>`;
    }
    return `<span class="text-muted small">${safe}</span>`;
  };
  if(stageConfirm){
    stageConfirm.addEventListener('click', async () => {
      if(stageConfirm.dataset.busy === '1') return;
      const selectedRows = ensureSelection();
      if(!selectedRows) return;
      if(!stageSelect){
        alert('Stage selector unavailable.');
        return;
      }
      const targetStage = stageSelect.value ? stageSelect.value.trim() : '';
      if(stageError){
        stageError.classList.add('d-none');
        stageError.textContent = '';
      }
      if(!targetStage){
        if(stageError){
          stageError.textContent = 'Choose a target stage before applying.';
          stageError.classList.remove('d-none');
        } else {
          alert('Choose a target stage before applying.');
        }
        stageSelect.focus();
        return;
      }
      if(targetStage === TRACKING_COMPLETED_STAGE){
        if(!window.confirm(TRACKING_COMPLETED_WARNING)){
          return;
        }
      }
      await withBusyState(stageConfirm, async () => {
        const payload = { stage: targetStage, rows: buildPayload(selectedRows) };
        const response = await submitBatch(batchEndpoints.stage, payload, stageError);
        if(!response) return;
        applyBatchSummary(response);
        if(stageSelect) stageSelect.value = '';
        if(stageModal){
          stageModal.hide();
        } else if(!showSelectedActive){
          resetFilters();
        }
      });
    });
  }
  if(wrikeConfirm){
    wrikeConfirm.addEventListener('click', async () => {
      if(wrikeConfirm.dataset.busy === '1') return;
      const selectedRows = ensureSelection();
      if(!selectedRows) return;
      const field = wrikeModalEl ? wrikeModalEl.dataset.field : null;
      if(!field || !batchEndpoints.wrike || !batchEndpoints.wrike[field]){
        alert('Wrike field unavailable.');
        resetFilters();
        return;
      }
      if(wrikeError){
        wrikeError.classList.add('d-none');
        wrikeError.textContent = '';
      }
      let value = wrikeInput ? wrikeInput.value.trim() : '';
      if(value && !/^\d{10}$/.test(value)){
        if(wrikeError){
          wrikeError.textContent = 'Enter a 10-digit Wrike ID or leave blank to clear it.';
          wrikeError.classList.remove('d-none');
        } else {
          alert('Wrike ID must be 10 digits or left blank.');
        }
        if(wrikeInput){
          wrikeInput.focus();
          wrikeInput.select();
        }
        return;
      }
      if(!value){
        value = null;
      }
      await withBusyState(wrikeConfirm, async () => {
        const payload = { value, rows: buildPayload(selectedRows) };
        const response = await submitBatch(batchEndpoints.wrike[field], payload, wrikeError);
        if(!response) return;
        applyBatchSummary(response);
        if(wrikeInput) wrikeInput.value = value || '';
        if(wrikeModal){
          wrikeModal.hide();
        } else if(!showSelectedActive){
          resetFilters();
        }
      });
    });
  }
  const wrikeDownloadBtn = document.getElementById('batch-wrike-download-excel');
  // Keep export configuration aligned with dashboard presets so generated sheets match expectations
  const wrikeExportTargets = {
    wrike_id1: {
      mode: 'pendingItems',
      columns: [
        'WorkingContractID',
        'ManufacturerNumber',
        'VendorItem',
        'ItemDescription',
        'BaseCost',
        'UOM',
        'DerivedUOMConversion',
        'EffectiveDate',
        'ExpirationDate',
      ],
    },
    wrike_id2: {
      mode: 'dashboard',
      tableKey: 'inventory',
      columnMode: 'inventory_setup_combined',
      columns: [
        'company',
        'location_ri',
        'replacement_item',
        'recommended_transaction_uom_ri',
        'recommended_preferred_bin_ri',
        'recommended_min_order_qty_ri',
        'recommended_max_order_qty_ri',
        'recommended_reorder_point_ri',
        'recommended_auto_replenishment_ri',
        'discontinued_ri',
        'manufacturer_number_ri',
        'setup_action',
        'notes',
        'preferred_bin_ri',
        'min_order_qty_ri',
        'max_order_qty_ri',
        'reorder_point_ri',
        'auto_replenishment_ri',
        'item_set',
      ],
    },
    wrike_id3: {
      mode: 'dashboard',
      tableKey: 'par',
      columnMode: 'par_setup_combined',
      columns: [
        'company',
        'location_ri',
        'location_text',
        'replacement_item',
        'manufacturer_number_ri',
        'item_description_ri',
        'recommended_min_order_qty_ri',
        'recommended_max_order_qty_ri',
        'recommended_reorder_point_ri',
        'stock_uom_ri',
        'recommended_preferred_bin_ri',
        'discontinued_ri',
        'setup_action',
        'notes',
        'preferred_bin_ri',
        'reorder_point_ri',
        'item_set',
      ],
    },
    wrike_id4: {
      mode: 'dashboard',
      tableKey: 'inventory',
      columnMode: 'inventory_item_description_update_original',
      columns: [
        'item_group_export',
        'replacement_item',
        'stock_uom',
        'reference2',
        'description2',
      ],
    },
  };
  const sanitizeDownloadSegment = (value) => {
    const cleaned = (value || '')
      .trim()
      .replace(/[\\/:*?"<>|]+/g, '-')
      .replace(/\s+/g, '_');
    return cleaned || 'NOT ENTERED';
  };
  const sanitizeDownloadFilename = (value) => {
    const cleaned = sanitizeDownloadSegment(value);
    return cleaned.endsWith('.xlsx') ? cleaned : `${cleaned}.xlsx`;
  };
  const getLocalDateStamp = () => {
    const now = new Date();
    const local = new Date(now.getTime() - now.getTimezoneOffset() * 60000);
    return local.toISOString().slice(0, 10);
  };
  const resolveWrikeIdForSelection = (rows, field) => {
    if(wrikeInput){
      const typed = wrikeInput.value.trim();
      if(typed){
        return { value: typed };
      }
    }
    const values = new Set();
    if(Array.isArray(rows)){
      rows.forEach(tr => {
        const cell = tr.querySelector(`.wrike-cell[data-field="${field}"]`);
        const cellValue = cell ? (cell.dataset.value || '').trim() : '';
        if(cellValue){
          values.add(cellValue);
        }
      });
    }
    if(values.size > 1){
      return { error: 'Selected rows contain multiple Wrike IDs. Enter a single Wrike ID before downloading.' };
    }
    if(values.size === 1){
      return { value: Array.from(values)[0] };
    }
    return { value: '' };
  };
  const buildWrikeDownloadFilename = (field, wrikeId) => {
    const baseMap = {
      wrike_id1: 'assign_item_number_Wrike',
      wrike_id2: 'set_up_inventory_Wrike',
      wrike_id3: 'set_up_par_Wrike',
      wrike_id4: 'item_description_update_original_Wrike',
    };
    const base = baseMap[field] || 'wrike_export';
    const cleanId = sanitizeDownloadSegment(wrikeId || 'NOT ENTERED');
    const dateStamp = getLocalDateStamp();
    return sanitizeDownloadFilename(`${base}[${cleanId}]_${dateStamp}.xlsx`);
  };
  const showWrikeDownloadError = (message) => {
    if(wrikeError){
      wrikeError.textContent = message;
      wrikeError.classList.remove('d-none');
    } else {
      alert(message);
    }
  };
  // Reuse dashboard export endpoint to build XLSX files for batch workflows
  const downloadDashboardExport = async (tableKey, params, preferredFilename) => {
    const url = `/dashboard/export/${tableKey}?${params.toString()}`;
    try {
  const resp = await appFetch(url, {
        headers: {
          'Accept': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/json',
        },
      });
      if(!resp.ok){
        let detail = '';
        try {
          detail = await resp.text();
        } catch {
          detail = '';
        }
        throw new Error(detail || `Export failed (${resp.status})`);
      }
      const blob = await resp.blob();
      let filename = preferredFilename || `${tableKey}-export.xlsx`;
      if(!preferredFilename){
        const disposition = resp.headers.get('Content-Disposition') || '';
        const match = disposition.match(/filename\*?=(?:UTF-8''|"?)([^";]+)/i);
        if(match && match[1]){
          const rawName = match[1].replace(/^"|"$/g, '');
          try {
            filename = decodeURIComponent(rawName);
          } catch {
            filename = rawName;
          }
        }
      }
      filename = sanitizeDownloadFilename(filename);
      const downloadUrl = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      window.URL.revokeObjectURL(downloadUrl);
      link.remove();
      return true;
    } catch (err) {
      console.error('Wrike download failed', err);
      showWrikeDownloadError(err && err.message ? err.message : 'Download failed.');
      return false;
    }
  };
  const downloadPendingItemsExport = async (itemLinkIds, columns, preferredFilename) => {
    const payload = {
      item_link_ids: itemLinkIds,
      columns,
    };
    try {
  const resp = await appFetch('/groups/batch/wrike/export/item-numbers', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/json',
        },
        body: JSON.stringify(payload),
      });
      const contentType = resp.headers.get('Content-Type') || '';
      if(!resp.ok){
        if(contentType.includes('application/json')){
          try {
            const data = await resp.json();
            throw new Error(data && data.message ? data.message : 'Download failed.');
          } catch (err) {
            throw new Error(err && err.message ? err.message : 'Download failed.');
          }
        }
        throw new Error(`Download failed (${resp.status})`);
      }
      if(!contentType.includes('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')){
        if(contentType.includes('application/json')){
          const data = await resp.json();
          throw new Error(data && data.message ? data.message : 'Unexpected response.');
        }
        throw new Error('Unexpected response type.');
      }
      const blob = await resp.blob();
      let filename = preferredFilename || 'wrike-get-item-numbers.xlsx';
      if(!preferredFilename){
        const disposition = resp.headers.get('Content-Disposition') || '';
        const match = disposition.match(/filename\*?=(?:UTF-8''|"?)([^";]+)/i);
        if(match && match[1]){
          const rawName = match[1].replace(/^"|"$/g, '');
          try {
            filename = decodeURIComponent(rawName);
          } catch {
            filename = rawName;
          }
        }
      }
      filename = sanitizeDownloadFilename(filename);
      const downloadUrl = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      window.URL.revokeObjectURL(downloadUrl);
      link.remove();
      return true;
    } catch (err) {
      console.error('Pending items download failed', err);
      showWrikeDownloadError(err && err.message ? err.message : 'Download failed.');
      return false;
    }
  };
  if(wrikeDownloadBtn){
    wrikeDownloadBtn.addEventListener('click', async () => {
      if(wrikeDownloadBtn.dataset.busy === '1') return;
      const selectedRows = ensureSelection();
      if(!selectedRows) return;
      if(wrikeError){
        wrikeError.classList.add('d-none');
        wrikeError.textContent = '';
      }
      const field = wrikeModalEl ? wrikeModalEl.dataset.field : null;
      const config = field ? wrikeExportTargets[field] : null;
      if(!config){
        showWrikeDownloadError('Excel export is unavailable for this task.');
        return;
      }
      const wrikeIdResult = resolveWrikeIdForSelection(selectedRows, field);
      if(wrikeIdResult.error){
        showWrikeDownloadError(wrikeIdResult.error);
        return;
      }
      const wrikeIdValue = wrikeIdResult.value || 'pending';
      const preferredFilename = buildWrikeDownloadFilename(field, wrikeIdValue);
      if(config.mode === 'pendingItems'){
        const payloadRows = buildPayload(selectedRows);
        const itemLinkIds = payloadRows
          .map(row => row.pkid)
          .filter(value => value !== undefined && value !== null && String(value).trim() !== '');
        if(!itemLinkIds.length){
          showWrikeDownloadError('Selected rows are missing ItemLink identifiers.');
          return;
        }
        await withBusyState(wrikeDownloadBtn, async () => {
          await downloadPendingItemsExport(itemLinkIds, config.columns, preferredFilename);
        });
        return;
      }
      if(config.mode === 'dashboard'){
        const itemGroups = [];
        selectedRows.forEach(tr => {
          const raw = tr.dataset.itemGroup;
          if(!raw) return;
          const value = raw.trim();
          if(!value) return;
          if(!/^\d+$/.test(value)) return;
          if(!itemGroups.includes(value)){
            itemGroups.push(value);
          }
        });
        if(!itemGroups.length){
          showWrikeDownloadError('Selected rows are missing item group values.');
          return;
        }
        const params = new URLSearchParams();
        params.set('row_scope', 'filtered');
        params.set('item_group', itemGroups.join(','));
        params.set('column_mode', config.columnMode);
        params.set('columns', config.columns.join(','));
        await withBusyState(wrikeDownloadBtn, async () => {
          await downloadDashboardExport(config.tableKey, params, preferredFilename);
        });
        return;
      }
      showWrikeDownloadError('Excel export configuration is invalid for this task.');
    });
  }

  if(goLiveConfirm){
    goLiveConfirm.addEventListener('click', async () => {
      if(goLiveConfirm.dataset.busy === '1') return;
      const selectedRows = ensureSelection();
      if(!selectedRows) return;
      if(goLiveError){
        goLiveError.classList.add('d-none');
        goLiveError.textContent = '';
      }
      let dateValue = goLiveInput ? goLiveInput.value.trim() : '';
      if(dateValue && !/^\d{4}-\d{2}-\d{2}$/.test(dateValue)){
        if(goLiveError){
          goLiveError.textContent = 'Enter a valid date (YYYY-MM-DD) or leave blank to clear it.';
          goLiveError.classList.remove('d-none');
        } else {
          alert('Enter a date in YYYY-MM-DD format or leave blank to clear it.');
        }
        if(goLiveInput){
          goLiveInput.focus();
        }
        return;
      }
      if(!dateValue){
        dateValue = null;
      }
      await withBusyState(goLiveConfirm, async () => {
        const payload = { expected_go_live_date: dateValue, rows: buildPayload(selectedRows) };
        const response = await submitBatch(batchEndpoints.goLive, payload, goLiveError);
        if(!response) return;
        applyBatchSummary(response);
        if(goLiveInput) goLiveInput.value = dateValue || '';
        if(goLiveModal){
          goLiveModal.hide();
        } else if(!showSelectedActive){
          resetFilters();
        }
      });
    });
  }
  if(!table) return;

  // Handle potential caching issues on reload
  if (performance.navigation.type === 1) {
    // This is a page reload - ensure data attributes are in sync
    console.log('Page was reloaded - refreshing data attributes');
    document.querySelectorAll('#itemlink-table .stage-cell').forEach(cell => {
      const badge = cell.querySelector('.stage-badge');
      if (badge) {
        cell.dataset.value = badge.innerText.trim();
      }
    });
  }

  table.addEventListener('click', async (e) => {
    const btn = e.target.closest('button');
    if(!btn) return;
    if(btn.classList.contains('batch-action-btn')){
      return;
    }
    const row = btn.closest('tr');
    if(btn.classList.contains('edit-btn')) {
      enterEdit(row, btn);
    } else if(btn.classList.contains('cancel-btn')) {
      exitEdit(row);
    } else if(btn.classList.contains('save-btn')) {
      await saveRow(row);
    }
  });

  const pushFragment = (fragments, value) => {
    if(value === null || value === undefined) return;
    const text = String(value).trim();
    if(text) fragments.push(text);
  };

  const getRowSearchText = (row) => {
    if(!row) return '';
    const fragments = [];
    const cells = row.cells ? Array.from(row.cells) : Array.from(row.querySelectorAll('td'));
    cells.forEach(cell => {
      if(cell.classList && cell.classList.contains('select-cell')){
        return;
      }

      if(cell.classList && cell.classList.contains('stage-cell')){
        const readSpan = cell.querySelector('.read-value');
        if(readSpan && !readSpan.classList.contains('d-none')){
          const badge = readSpan.querySelector('.stage-badge');
          pushFragment(fragments, badge ? badge.innerText : readSpan.innerText);
        } else {
          const stageSelectEl = cell.querySelector('select');
          if(stageSelectEl && !stageSelectEl.classList.contains('d-none')){
            const selectedOption = (stageSelectEl.selectedOptions && stageSelectEl.selectedOptions.length)
              ? stageSelectEl.selectedOptions[0].text
              : stageSelectEl.value;
            pushFragment(fragments, selectedOption);
          } else {
            pushFragment(fragments, cell.dataset ? cell.dataset.value : '');
          }
        }
        return;
      }

      const readValueEl = cell.querySelector('.read-value');
      if(readValueEl && !readValueEl.classList.contains('d-none')){
        pushFragment(fragments, readValueEl.innerText);
        return;
      }

      if(cell.classList && cell.classList.contains('wrike-cell')){
        const activeInput = cell.querySelector('input:not(.d-none)');
        if(activeInput){
          pushFragment(fragments, activeInput.value);
        } else {
          pushFragment(fragments, cell.dataset ? cell.dataset.value : '');
        }
        return;
      }

      if(cell.classList && cell.classList.contains('date-cell')){
        const activeInput = cell.querySelector('input:not(.d-none)');
        if(activeInput){
          pushFragment(fragments, activeInput.value);
        } else {
          pushFragment(fragments, cell.dataset ? cell.dataset.value : '');
        }
        return;
      }

      const ellipsisEl = cell.querySelector('.ellipsis-text');
      if(ellipsisEl){
        pushFragment(fragments, ellipsisEl.innerText);
        return;
      }

      const directText = Array.from(cell.childNodes || [])
        .filter(node => node.nodeType === TEXT_NODE)
        .map(node => node.textContent || '')
        .join(' ');
      if(directText && directText.trim()){
        pushFragment(fragments, directText);
      } else {
        pushFragment(fragments, cell.innerText || '');
      }
    });

    return fragments.join(' ').replace(/\s+/g, ' ').trim().toLowerCase();
  };

  // Filter logic (client side)
  function applyFilter(){
    const qRaw = filterInput.value.trim();
    const rawTokens = qRaw
      .split(';')
      .map(part => part.trim().toLowerCase())
      .filter(Boolean);
    const mode = filterMode.value;
    const tokenLimit = getTokenLimit(mode);
    const tokens = rawTokens.slice(0, tokenLimit);
    const truncated = rawTokens.length > tokens.length;
    setFilterHint(tokenLimit, truncated);
    const rows = table.tBodies[0].rows;
    let visible = 0;

    for(const tr of rows){
      if(tr.dataset.item === undefined){
        continue;
      }
      let match = true;
      let rowSearchText = null;

      if(tokens.length){
        if(mode === 'contains'){
          if(rowSearchText === null){
            rowSearchText = getRowSearchText(tr);
          }
          match = tokens.some(token => rowSearchText.includes(token));
        } else if(mode === 'not-contains'){
          if(rowSearchText === null){
            rowSearchText = getRowSearchText(tr);
          }
          match = tokens.every(token => !rowSearchText.includes(token));
        } else if(mode === 'item-group'){
          const groupValue = getItemGroupValue(tr);
          match = tokens.some(token => groupValue === token);
        } else if(mode === 'stage'){
          const stageCell = tr.querySelector('.stage-cell .stage-badge');
          const stageText = stageCell ? stageCell.innerText.trim().toLowerCase() : '';
          match = tokens.some(token => stageText.includes(token));
        } else if(mode === 'item' || mode === 'replace-item'){
          const value = getRowValueForMode(tr, mode);
          match = tokens.some(token => value.includes(token));
        }
      }

      tr.classList.toggle('d-none', !match);
      if(match) visible++;
    }

    if(visibleCountEl) visibleCountEl.textContent = visible;
    syncSelectAll();
  }
  if(filterInput && filterMode){
    filterInput.addEventListener('input', applyFilter);
    filterMode.addEventListener('change', applyFilter);
    applyFilter();
  }

  if(filterClearBtn){
    filterClearBtn.addEventListener('click', () => {
      if(filterInput){
        filterInput.value = '';
      }
      if(filterMode){
        filterMode.value = 'contains';
      }
      resetFilters();
      if(filterInput){
        filterInput.focus();
      }
    });
  }

  function enterEdit(row, editButton){
    row.querySelectorAll('.read-value').forEach(el => el.classList.add('d-none'));
    row.querySelectorAll('select, input:not([type="checkbox"])').forEach(el => el.classList.remove('d-none'));
    const actionDiv = row.querySelector('.action-buttons');
    actionDiv.classList.remove('d-none');
    editButton.classList.add('d-none');
    row.classList.add('table-warning');

    // Stage transition filtering per rules
    const stageCell = row.querySelector('.stage-cell');
    if(stageCell){
      const current = stageCell.dataset.value || '';
      const sel = stageCell.querySelector('select[name="stage"]');
      if(sel){
        const allowedTargets = allowedTargetsForStage(current);
        Array.from(sel.options).forEach(opt => {
          if(!opt.value){
            opt.disabled = false;
            return;
          }
          opt.disabled = !allowedTargets.has(opt.value);
        });

        if(current === TRACKING_COMPLETED_STAGE){
          sel.title = 'Tracking Completed is final. Archive to revive the row.';
        } else {
          sel.removeAttribute('title');
        }
        
        // Ensure the current value is selected
        sel.value = current;
      }
    }
  }

  function exitEdit(row){
    row.querySelectorAll('.read-value').forEach(el => el.classList.remove('d-none'));
    row.querySelectorAll('select, input:not([type="checkbox"])').forEach(el => el.classList.add('d-none'));
    const actionDiv = row.querySelector('.action-buttons');
    actionDiv.classList.add('d-none');
    row.querySelector('.edit-btn').classList.remove('d-none');
    row.classList.remove('table-warning');
    // Reset input values to original data-value attributes
    const stageCell = row.querySelector('.stage-cell');
    const dateCell = row.querySelector('.date-cell');
    if(stageCell){
      const sel = stageCell.querySelector('select');
      sel.value = stageCell.dataset.value || '';
    }
    if(dateCell){
      const inp = dateCell.querySelector('input');
      inp.value = dateCell.dataset.value || '';
    }
    row.querySelectorAll('.wrike-cell').forEach(cell => {
      const inp = cell.querySelector('input');
      if(inp){
        inp.value = cell.dataset.value || '';
      }
    });
    const rowCheckbox = row.querySelector('.row-select');
    if(rowCheckbox){
      rowCheckbox.classList.remove('d-none');
    }
  }
  async function saveRow(row){
    const item = row.dataset.item;
    const replaceItem = row.dataset['replaceItem'];
    const stageSelect = row.querySelector('select[name="stage"]');
    const stage = stageSelect ? stageSelect.value.trim() : '';
    const dateVal = row.querySelector('input[name="expected_go_live_date"]').value;
    const currentStage = (row.querySelector('.stage-cell')?.dataset.value || '').trim();

    if(stage === TRACKING_COMPLETED_STAGE && currentStage !== TRACKING_COMPLETED_STAGE){
      if(!window.confirm(TRACKING_COMPLETED_WARNING)){
        return;
      }
    }
    
    try {
      const formData = new FormData();
      formData.append('stage', stage);
      if(dateVal) formData.append('expected_go_live_date', dateVal);
      ['wrike_id1','wrike_id2','wrike_id3','wrike_id4'].forEach(field => {
        const input = row.querySelector(`input[name="${field}"]`);
        if(!input) return;
        formData.append(field, input.value.trim());
      });
      
  const resp = await appFetch(`/groups/${encodeURIComponent(item)}/${encodeURIComponent(replaceItem)}/update`, {
        method: 'POST',
        body: formData,
        headers: { 'Accept': 'application/json', 'X-Requested-With': 'fetch' }
      });
      
      if(!resp.ok){
        let msg = 'Update failed';
        try { const err = await resp.json(); if(err.message) msg = err.message; } catch {}
        alert(msg);
        return;
      }
      const data = await resp.json();
      if(data.status !== 'ok'){
        alert(data.message || 'Update failed');
        return;
      }
      // Update UI with returned record
      const rec = data.record;
      const newStage = (rec.stage || '').trim();
      // Maintain deleted count and toggle Clear Deleted button if stage changed
      try {
        updateDeletedCountUI({ providedCount: data.count_deleted, oldStage: currentStage, newStage });
        updateCompletedCountUI({ providedCount: data.count_completed, oldStage: currentStage, newStage });
  } catch(e){ console.warn('Could not update stage counters', e); }
      // Stage update
      const stageCell = row.querySelector('.stage-cell');
      if(stageCell){
        stageCell.dataset.value = rec.stage || '';
        const badgeWrap = stageCell.querySelector('.read-value');
        if(badgeWrap){
          badgeWrap.innerHTML = rec.stage ? `<span class="badge stage-badge stage-${(rec.stage||'').toLowerCase().replace(/ /g,'-')}">${rec.stage}</span>` : '';
        }
        const sel = stageCell.querySelector('select');
        if(sel) sel.value = rec.stage || '';
        if(stageStats){
          stageStats.handleStageChange(currentStage, rec.stage || '');
        }
      }
      // Date update
      const dateCell = row.querySelector('.date-cell');
      if(dateCell){
        dateCell.dataset.value = rec.expected_go_live_date || '';
        const span = dateCell.querySelector('.read-value');
        if(span){
          if(!rec.expected_go_live_date){
            span.innerHTML = '<span class="text-muted fst-italic">unknown</span>';
          } else {
            span.textContent = rec.expected_go_live_date;
          }
        }
        const inp = dateCell.querySelector('input');
        if(inp) inp.value = rec.expected_go_live_date || '';
      }
        ['wrike_id1','wrike_id2','wrike_id3','wrike_id4'].forEach(field => {
          const cell = row.querySelector(`.wrike-cell[data-field="${field}"]`);
          if(!cell) return;
          const span = cell.querySelector('.read-value');
          const input = cell.querySelector('input');
          const value = rec[field] || '';
          cell.dataset.value = value || '';
          if(span){
            span.innerHTML = formatWrikeHtml(value);
          }
          if(input){
            input.value = value || '';
          }
        });
      // Update update_dt column (last cell)
      const updateCell = row.lastElementChild; // update_dt is last td
      if(updateCell){
        if(rec.update_dt){
          try { updateCell.textContent = new Date(rec.update_dt).toISOString().slice(0,19).replace('T',' '); } catch { updateCell.textContent = rec.update_dt; }
        }
      }
      exitEdit(row);
      refreshAllRowSelectionStates();
    } catch (err) {
      console.error('Error saving row:', err);
      alert('An error occurred while saving');
    }
  }

  function setBatchMode(enabled){
    if(!table) return;
    if(enabled){
      table.querySelectorAll('tr.table-warning').forEach(row => exitEdit(row));
      if(selectHeader) selectHeader.classList.remove('d-none');
      table.querySelectorAll('.select-cell').forEach(cell => cell.classList.remove('d-none'));
      if(editHeader) editHeader.classList.add('d-none');
      table.querySelectorAll('.edit-cell').forEach(cell => cell.classList.add('d-none'));
      batchButtons.forEach(btn => btn.disabled = false);
      if(selectedCountContainer){
        selectedCountContainer.classList.remove('d-none');
      }
      if(showSelectedBtn){
        showSelectedBtn.classList.remove('d-none');
        showSelectedBtn.classList.remove('active');
        showSelectedBtn.disabled = getSelectedRows().length === 0;
      }
      if(showAllBtn){
        showAllBtn.classList.add('d-none');
        showAllBtn.disabled = true;
      }
      showSelectedActive = false;
      refreshAllRowSelectionStates();
    } else {
      if(selectHeader) selectHeader.classList.add('d-none');
      table.querySelectorAll('.select-cell').forEach(cell => {
        cell.classList.add('d-none');
        const checkbox = cell.querySelector('.row-select');
        if(checkbox) checkbox.checked = false;
      });
      if(selectAll) selectAll.checked = false;
      if(selectAll) selectAll.indeterminate = false;
      if(editHeader) editHeader.classList.remove('d-none');
      table.querySelectorAll('.edit-cell').forEach(cell => cell.classList.remove('d-none'));
      batchButtons.forEach(btn => btn.disabled = true);
      updateSelectedCount();
      if(selectedCountContainer){
        selectedCountContainer.classList.add('d-none');
      }
      if(showSelectedBtn){
        showSelectedBtn.classList.add('d-none');
        showSelectedBtn.disabled = true;
        showSelectedBtn.classList.remove('active');
      }
      if(showAllBtn){
        showAllBtn.classList.add('d-none');
        showAllBtn.disabled = true;
      }
      showSelectedActive = false;
      resetFilters();
      refreshAllRowSelectionStates();
    }
  }

  if(batchToggle){
    batchToggle.addEventListener('change', (event) => {
      setBatchMode(event.target.checked);
    });
    setBatchMode(batchToggle.checked);
  } else {
    batchButtons.forEach(btn => btn.disabled = true);
  }

  if(selectAll){
    selectAll.addEventListener('change', (event) => {
      const checked = event.target.checked;
      selectAll.indeterminate = false;
      const scopedCheckboxes = checked ? getVisibleCheckboxes() : getAllRowCheckboxes();
      scopedCheckboxes.forEach(cb => {
        if(checked){
          if(!cb.disabled){
            cb.checked = true;
          }
        } else {
          cb.checked = false;
        }
      });
      syncSelectAll();
    });
  }

  if(table){
    table.addEventListener('change', (event) => {
      const cb = event.target.closest('.row-select');
      if(!cb) return;
      syncSelectAll();
    });
  }

  function getSelectedRows(){
    if(!table) return [];
    return Array.from(table.querySelectorAll('tbody tr')).filter(tr => tr.querySelector('.row-select')?.checked);
  }

  function ensureSelection(){
    const selected = getSelectedRows();
    if(!selected.length){
      alert('Select at least one row to continue.');
      return false;
    }
    return selected;
  }

  function filterToSelectedRows(){
    const selected = getSelectedRows();
    if(!selected.length){
      return selected;
    }
    const selectedSet = new Set(selected);
    Array.from(table.querySelectorAll('tbody tr')).forEach(tr => {
      const isSelected = selectedSet.has(tr);
      tr.classList.toggle('batch-filtered-out', !isSelected);
      tr.classList.toggle('d-none', !isSelected);
      if(isSelected){
        tr.classList.remove('d-none');
      }
    });
    syncSelectAll();
    if(filterInput) filterInput.disabled = true;
    if(filterMode) filterMode.disabled = true;
    if(table) table.dataset.batchFilterActive = '1';
    if(visibleCountEl) visibleCountEl.textContent = selected.length;
    return selected;
  }

  function activateShowSelectedView({ auto = false } = {}){
    const selectedRows = getSelectedRows();
    if(!selectedRows.length){
      return [];
    }
    if(filterInput){
      filterInput.value = '';
    }
    if(filterMode){
      filterMode.value = 'contains';
    }
    const visibleSelection = filterToSelectedRows();
    if(!visibleSelection.length){
      return visibleSelection;
    }
    showSelectedActive = true;
    if(table) table.dataset.showSelectedView = '1';
    if(showSelectedBtn){
      showSelectedBtn.classList.remove('d-none');
      showSelectedBtn.classList.add('active');
      showSelectedBtn.disabled = true;
    }
    if(showAllBtn){
      showAllBtn.classList.remove('d-none');
      showAllBtn.disabled = false;
    }
    if(selectedCountContainer){
      selectedCountContainer.classList.remove('d-none');
    }
    const firstRow = visibleSelection[0];
    if(firstRow && typeof firstRow.scrollIntoView === 'function'){
      firstRow.scrollIntoView({ behavior: auto ? 'auto' : 'smooth', block: 'center' });
    }
    if(!auto){
      visibleSelection.forEach(row => row.classList.add('show-selected-highlight'));
      window.setTimeout(() => {
        visibleSelection.forEach(row => row.classList.remove('show-selected-highlight'));
      }, 1600);
    }
    return visibleSelection;
  }

  function resetFilters(){
    Array.from(table.querySelectorAll('tbody tr')).forEach(tr => {
      tr.classList.remove('batch-filtered-out');
      tr.classList.remove('d-none');
    });
    if(table){
      table.dataset.batchFilterActive = '';
      table.dataset.showSelectedView = '';
    }
    table.querySelectorAll('.show-selected-highlight').forEach(row => row.classList.remove('show-selected-highlight'));
    if(filterInput) filterInput.disabled = false;
    if(filterMode) filterMode.disabled = false;
    if(showSelectedActive){
      showSelectedActive = false;
      if(showSelectedBtn){
        showSelectedBtn.classList.remove('active');
        showSelectedBtn.disabled = getSelectedCheckboxes().length === 0;
      }
      if(showAllBtn){
        showAllBtn.classList.add('d-none');
        showAllBtn.disabled = true;
      }
    }
    applyFilter();
    syncSelectAll();
  }

  [stageModalEl, wrikeModalEl, goLiveModalEl].forEach(modalEl => {
    if(!modalEl) return;
    modalEl.addEventListener('hidden.bs.modal', () => {
      if(!showSelectedActive){
        resetFilters();
      }
      clearErrors();
    });
  });

  function clearErrors(){
    [stageError, wrikeError, goLiveError].forEach(alertBox => {
      if(alertBox){
        alertBox.classList.add('d-none');
        alertBox.textContent = '';
      }
    });
  }

  if(showSelectedBtn){
    showSelectedBtn.addEventListener('click', () => {
      if(showSelectedActive) return;
      if(!ensureSelection()) return;
      activateShowSelectedView({ auto: false });
    });
  }

  if(showAllBtn){
    showAllBtn.addEventListener('click', () => {
      if(showAllBtn.disabled) return;
      resetFilters();
    });
  }

  batchButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const selected = ensureSelection();
      if(!selected) return;
      const action = btn.dataset.action;
      let stageSummary = null;
      if(action === 'stage'){
        stageSummary = summarizeSelectionStages(selected);
        if(!stageSummary.singleStage){
          alert(MULTI_STAGE_SELECTION_ALERT);
          return;
        }
      }
      if(action === 'wrike_id1'){
        const allPending = selected.every(row => stageMatches(getRowStageValue(row), STAGE_PENDING_ITEM_NUMBER));
        if(!allPending){
          alert(WRIKE_ID1_STAGE_REQUIREMENT_MESSAGE);
          return;
        }
      }
      if(action === 'wrike_id2' || action === 'wrike_id3'){
        const allPendingClinical = selected.every(row => stageMatches(getRowStageValue(row), STAGE_PENDING_CLINICAL_READINESS));
        if(!allPendingClinical){
          alert(action === 'wrike_id2' ? WRIKE_ID2_STAGE_REQUIREMENT_MESSAGE : WRIKE_ID3_STAGE_REQUIREMENT_MESSAGE);
          return;
        }
      }
      if(action === 'wrike_id4'){
        const allAllowed = selected.every(row => {
          const stageValue = getRowStageValue(row);
          return stageMatches(stageValue, STAGE_PENDING_CLINICAL_READINESS)
            || stageMatches(stageValue, STAGE_TRACKING_ITEM_TRANSITION)
            || stageMatches(stageValue, STAGE_TRACKING_DISCONTINUED);
        });
        if(!allAllowed){
          alert(WRIKE_ID4_STAGE_REQUIREMENT_MESSAGE);
          return;
        }
      }
      const visibleSelection = filterToSelectedRows();
      if(!visibleSelection.length){
        return;
      }
      clearErrors();
      if(action === 'stage'){
        if(stageSelect){
          configureBatchStageSelect(stageSummary ? stageSummary.stage : '');
        }
        if(stageModal){
          stageModal.show();
        } else {
          alert('Batch stage modal unavailable. Ensure Bootstrap JavaScript is loaded.');
          resetFilters();
        }
      } else if(action?.startsWith('wrike')){
        if(wrikeInput) wrikeInput.value = '';
        if(wrikeInputLabel){
          if(action === 'wrike_id1') wrikeInputLabel.textContent = 'Wrike ID (Get Item #)';
          if(action === 'wrike_id2') wrikeInputLabel.textContent = 'Wrike ID (Set-up Inv.)';
          if(action === 'wrike_id3') wrikeInputLabel.textContent = 'Wrike ID (Set-up Par)';
          if(action === 'wrike_id4') wrikeInputLabel.textContent = 'Wrike ID (Update Desc)';
        }
        if(wrikeModalTitle){
          if(action === 'wrike_id1') wrikeModalTitle.textContent = 'Create Wrike Task - Get Item #';
          if(action === 'wrike_id2') wrikeModalTitle.textContent = 'Create Wrike Task - Set-up Inv.';
          if(action === 'wrike_id3') wrikeModalTitle.textContent = 'Create Wrike Task - Set-up Par';
          if(action === 'wrike_id4') wrikeModalTitle.textContent = 'Create Wrike Task - Update Desc.';
        }
        if(wrikeDownloadBtn){
          // Only enable Excel export for Wrike flows that have a dashboard preset backing it
          const config = wrikeExportTargets[action];
          if(config){
            wrikeDownloadBtn.disabled = false;
            wrikeDownloadBtn.title = '';
          } else {
            wrikeDownloadBtn.disabled = true;
            wrikeDownloadBtn.title = 'Excel export unavailable for this task.';
          }
        }
        if(wrikeModalEl) wrikeModalEl.dataset.field = action;
        if(wrikeModal){
          wrikeModal.show();
        } else {
          alert('Batch Wrike modal unavailable. Ensure Bootstrap JavaScript is loaded.');
          resetFilters();
        }
      } else if(action === 'go_live'){
        if(goLiveInput) goLiveInput.value = '';
        if(goLiveModal){
          goLiveModal.show();
        } else {
          alert('Batch Go Live modal unavailable. Ensure Bootstrap JavaScript is loaded.');
          resetFilters();
        }
      } else {
        resetFilters();
      }
    });
  });
});
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // Acquire references (some may already be defined in previous script block; guard redefinitions)
  const table = document.getElementById('itemlink-table');
  if(!table) return;
  const thead = table.tHead;
  const tbody = table.tBodies[0];
  const headers = Array.from(thead.querySelectorAll('th.sortable'));

  // Preserve original order index for stable sort / reset
  Array.from(tbody.rows).forEach((tr, idx) => tr.dataset._orig = idx);

  let currentSort = { index: null, dir: 'asc' };

  function getCellValue(tr, idx, type){
    const cell = tr.cells[idx];
    if(!cell) return '';
    let raw = cell.innerText.trim();
    if(type === 'number'){
      const n = parseFloat(raw.replace(/[^0-9.-]/g,''));
      return isNaN(n) ? Number.NEGATIVE_INFINITY : n; // blanks -> very small
    }
    if(type === 'date'){
      // Expect YYYY-MM-DD or 'unknown'
      if(/\d{4}-\d{2}-\d{2}/.test(raw)) return raw; // lexicographic works for ISO dates
      return '9999-99-99';
    }
    if(type === 'datetime'){
      // Format 'YYYY-MM-DD HH:MM:SS'
      if(/\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/.test(raw)) return raw; // ISO-like
      return '9999-99-99 99:99:99';
    }
    if(type === 'stage'){
      const badge = cell.querySelector('.stage-badge');
      raw = badge ? badge.innerText.trim() : '';
      return raw.toLowerCase();
    }
    if(type === 'wrike'){
      const dataValue = cell.dataset.value || raw;
      return dataValue || '';
    }
    return raw.toLowerCase();
  }

  function sortBy(idx, type){
    // Toggle direction
    if(currentSort.index === idx){
      currentSort.dir = currentSort.dir === 'asc' ? 'desc' : 'asc';
    } else {
      currentSort.index = idx;
      currentSort.dir = 'asc';
    }

    headers.forEach((h,i)=>{
      h.classList.toggle('active', i===idx);
      const ind = h.querySelector('.sort-indicator');
      if(ind){
        if(i===idx){
          ind.textContent = currentSort.dir === 'asc' ? '▲' : '▼';
        } else {
          ind.textContent = ''; // clear others
        }
      }
    });

    const rows = Array.from(tbody.rows).filter(r=>r.dataset.item !== undefined);
    const dirMod = currentSort.dir === 'asc' ? 1 : -1;

    rows.sort((a,b)=>{
      const va = getCellValue(a, idx, type);
      const vb = getCellValue(b, idx, type);
      if(type === 'number'){
        return (va - vb) * dirMod || (a.dataset._orig - b.dataset._orig);
      }
      if(va < vb) return -1 * dirMod;
      if(va > vb) return 1 * dirMod;
      return (a.dataset._orig - b.dataset._orig); // stable
    });

    // Re-append in sorted order
    rows.forEach(r=>tbody.appendChild(r));
  }

  headers.forEach((th, idx) => {
    th.addEventListener('click', (e) => {
      // Avoid sorting if clicking on a form control inside header
      if(e.target.closest('button, input, select')) return;
      const type = th.dataset.type || 'text';
      // If type none, still allow resetting to original order toggle
      if(type === 'none'){
        // Reset to original order
        currentSort = { index: null, dir: 'asc' };
        headers.forEach(h=>{ h.classList.remove('active'); const ind = h.querySelector('.sort-indicator'); if(ind) ind.textContent=''; });
        const rows = Array.from(tbody.rows).filter(r=>r.dataset.item !== undefined).sort((a,b)=>a.dataset._orig - b.dataset._orig);
        rows.forEach(r=>tbody.appendChild(r));
        return;
      }
      sortBy(idx, type);
    });
  });
});
</script>
{% endblock %}
